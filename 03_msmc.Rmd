---
title: "MSMC Analysis"
output: github_document
---

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(fig.width=12, fig.height=8,
                      echo=FALSE, warning=FALSE, message=FALSE)
```

```{r}
library(tidyverse)
```


We used deep sequencing data for 10 samples to infer demographic history from the distribution of heterozygous sites using [msmc2](https://github.com/stschiff/msmc2). Since each sample is analysed separately the variation in inferred histories between samples provides a measure of uncertainty.  In addition we performed 100 bootstrap replicates for each 

Data was therefore prepared for msmc analysis as follows;

- The genome was masked using the [snpable](http://lh3lh3.users.sourceforge.net/snpable.shtml) suite of utilities. See [02_snpable.sh](hpc/msmc/02_snpable.sh) for details.
- Only contigs larger than 1Mb were included 
- A mappability mask was generated using `makeMappabilityMask.py` from [msmc-tools](https://github.com/stschiff/msmc-tools)
- SNPs were called using the `bamCaller` python script. See [04_covered_sites.sh](hpc/msmc/04_covered_sites.sh) for details
- Inputs for a single run were generated with the script `generate_multihetsep.py` from [msmc-tools](https://github.com/stschiff/msmc-tools)
- Inputs for bootstraps were generated using the script `multihetsep_bootstrap.py` from [msmc-tools](https://github.com/stschiff/msmc-tools).  100 bootstraps were generated by taking 40 random chunks (per chromosome) of size 500kb and assembling these into 15 "chromosomes". 
- The [msmc2](https://github.com/stschiff/msmc2) program was run on each bootstrap using options appropriate for a single diploid sample (see script [07_bootstrap.sh](hpc/msmc/08_bootstrap.sh))


```{r}
read_final <- function(path){
  ids_to_pops <- c("DC1105"="C3",
                   "DC1107"="C2",
                   "DC1108"="C2",
                   "DC1109"="C3",
                   "DC7955"="C3",
                   "DC7957"="C3",
                   "DC7962"="C2",
                   "DC7967"="C1",
                   "DC7968"="C2",
                   "DC7969"="C1")
  ids_to_locations <- c("DC1105"="Myr",
                        "DC1107"="Myr",
                        "DC1108"="Myr",
                        "DC1109"="Myr",
                        "DC7955"="GD",
                        "DC7957"="GD",
                        "DC7962"="GD",
                        "DC7967"="GD",
                        "DC7968"="GD",
                        "DC7969"="GD")
  
  id <- basename(path) %>% stringr::str_extract("DC[^_]+")
  read_tsv(path) %>% 
    add_column(ID=id) %>% 
    add_column(Pop=ids_to_pops[id]) %>% 
    add_column(Loc=ids_to_locations[id])
}

read_bootstraps <- function(indv){
  bs_files <- list.files(paste("hpc/msmc/",indv,"_within_msmc_bs",sep=""),"*.final.txt", full.names = TRUE)

  data <- do.call(rbind,lapply(bs_files,function(fn){
    bsrep <- basename(fn) %>% stringr::str_extract("[^_]+")
    read_final(fn) %>% add_column(bootstrap = bsrep)
  }))
  data
}
```


```{r}
mu <- 4.83e-8 # mu Prada
#mu <- 7.3e-9 # mu Cooke (Tenuis)
#mu <- 2.9e-8 # mu Mao
gen <- 35

individuals <- c("DC1105","DC1107","DC1108","DC1109","DC7955","DC7957","DC7962","DC7967","DC7968","DC7969")

dp <- read_table("hpc/msmc/read_depths_av.txt",col_names = c("ID","D")) %>% 
  filter(ID %in% individuals)

dp_low <- read_table("hpc/msmc/read_depths_av.txt",col_names = c("ID","D")) %>% 
  filter(!(ID %in% individuals))

if ( !file.exists("cache/msmc_bootstraps.rds") ){
  bs_data <- do.call(rbind,lapply(individuals,read_bootstraps))
  write_rds(bs_data,path = "cache/msmc_bootstraps.rds")
} else {
  bs_data <- read_rds("cache/msmc_bootstraps.rds")
}

bs_av <- bs_data %>% 
  group_by(ID,Pop,Loc,time_index) %>%
  summarise(left_time_boundary=mean(left_time_boundary),
            right_time_boundary=mean(right_time_boundary),
            lambda=mean(lambda))

ymax <- bs_av %>% mutate(y=(1/lambda)/mu) %>% pull(y) %>% max()

msmc_step_plot <- ggplot(bs_av,aes(x=left_time_boundary/mu*gen,y=(1/lambda)/mu)) + 
  geom_step(size=1,aes(group=ID,color=Pop)) + 
  scale_color_manual(values = c("C3" = "#e41a1c","C2" = "#377eb8", "C1" = "#4daf4a")) +
  scale_x_log10(breaks=c(1e+4,1e+5,1e+6,1e+7), labels=c("10kya","100kya","1mya","10mya")) +
  xlab("Years Ago") + 
  ylab(expression(paste("Effective Population Size ",N[e]))) + 
  theme_minimal() + 
  theme(text=element_text(size=20), legend.title = element_blank()) + 
  guides(color='none') +
  facet_wrap(~Loc, ncol = 1) #+
  # geom_vline(xintercept = 1e5) +
  # geom_vline(xintercept = 2e5) +
  # geom_vline(xintercept = 5e5) +

ggsave(msmc_step_plot,filename = "figures/msmc_step_id.png",width=14)
```

```{r}
bs_data_id <- bs_data %>% unite(bsid,ID,bootstrap,remove = FALSE)

ggplot(bs_av,aes(x=(left_time_boundary/mu)*gen,y=(1/lambda)/mu)) + 
#  geom_step(data = bs_data_id,size=1,aes(group=bsid,color=Pop),alpha=0.1) + 
  geom_step(data = bs_av,size=0.5,aes(group=ID,color=Pop),alpha=1,linetype=1) + 
 # geom_smooth(aes(color=Pop,fill=Pop),span=0.2,se=FALSE) +
  scale_color_manual(values = c("C3" = "#e41a1c","C2" = "#377eb8", "C1" = "#4daf4a")) +
  scale_x_log10(breaks=c(1e+4,1e+5,1e+6,1e+7), labels=c("10kya","100kya","1mya","10mya")) +
  xlab('Years ago') +
  ylab(expression(paste("Effective Population Size ",N[e]))) + 
  theme_minimal() + 
  theme(text=element_text(size=20), legend.title = element_blank()) + 
#  guides(color='none',fill='none') +
  ylim(0,ymax*1.2) +
  scale_y_continuous(labels = scales::scientific)
  # geom_vline(xintercept = 1e5) +
  # geom_vline(xintercept = 2e5) +
  # geom_vline(xintercept = 5e5) +

ggsave(filename = "figures/msmc_step.png",width=12)
```

```{r}
library(ggpubr)
bs_av_p <- bs_av %>% 
  mutate(generations = left_time_boundary/mu) %>% 
  mutate(time = generations*gen) %>% 
  mutate(Ne = (1/lambda)/mu) 

ggplot(bs_av_p,aes(x=generations,y=Ne)) +
  geom_step(data = bs_av_p,size=0.5,aes(group=ID,color=Pop),alpha=0.5,linetype=1) + 
  geom_smooth(aes(color=Pop,fill=Pop),span=0.2,se=FALSE) +  
  scale_color_manual(values = c("C3" = "#e41a1c","C2" = "#377eb8", "C1" = "#4daf4a")) +
  scale_x_log10() + 
  annotate(geom="text",x=c(1e3,1e4,1e5,1e6),y=-0.5e4,label = c("1e3","1e4","1e5","1e6")) + 
  annotate(geom="text",x=c(1e5/gen,1e6/gen,1e7/gen),y=-1.5e4,label = c("100kya","1Mya","10Mya")) + 
  
  theme_pubclean() +
  coord_cartesian(ylim = c(0, 1.4e5),xlim=c(0.8e3,1.2e6), expand = FALSE, clip = "off") +  
  theme(plot.margin = unit(c(1, 1, 4, 1), "lines"),
        axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank()) +
  theme(legend.position = "None", text = element_text(size=12)) + 
  ylab(expression(paste("Effective Population Size, ",N[e]))) +
  
#ggsave(filename = "figures/msmc_step_gen.png",units = "cm" ,width=16,height=10)
ggsave(filename = "figures/msmc_step_gen.pdf",units = "cm" ,width=16,height=10)
```





